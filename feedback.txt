
**Improvements**

Shell (class and package): Not a domain name—too technical.

Shell: Too many collaborators. Clear sign that the class is doing too much and
that the design is not quite right.

Shell/Console: Shell uses Scanner to read from console and Console (class) to
print. Why Console class doesn’t read from console as well?

Shell.submit(): Misnomer. JavaDoc starts with “Parse…” I would call this method
“execute(shellCommand)” instead and would delete the JavaDoc.

Shell.submit(): It highlights a design problem. If you need to use “instanceof”
and casting when you have an interface (Command in this case), the interface is
not good enough—it’s not abstracting as it should.

Shell.submit(): Violates OCP. If you add a new Command, this method needs to be
changed. It shouldn’t be the case if Command interface was better defined.


Shell: The class violates OCP and SRP. It has the behaviour of all commands and
would need to be changed if a new command is added or a command is removed.




CommandParser: This should be the only (factory) class that knows about different
commands. The rest of the application should only deal with the Command
interface (with no instanceof or casting).

Command: Badly implemented. It should be implemented as the Command pattern
(GoF Pattern) with a single method execute(). There are a few ways you could
implement it: a) Pass the shellCommand and Repository into the constructor and
have an execute() method with no parameters; b) Pass the Repository in the
constructor and pass the shellCommand as a parameter to the execute(shellCommand)
method. The command would know if the shellCommand belongs to it, would parse it,
and invoke the respective method on the repository.

Command implementations (Follow, Post, View, Wall): Should not be dummy data
structures. It should have the respective behaviour (currently on Shell class).
If done like described here and above, there wouldn’t be a need to have a
public method to return the user name.



Repositories: No need for 3 repositories. A single repository with a single
internal data structure would be enough to get all the data you need for each
method (read, wall).

OrderedPosts: Is this a domain class? This looks to me a thing that a repository
should do for you when asking for the wall posts.

Subscriptions: This word does not exist in the domain language. This would go
away if the “only” repository had a better data structure. Maybe the User could
have a list of users he or she follows? That way, you could get all the posts
from the user and followed users, add them to the same list, and sort them.

Timeline: Public methods size() and anyMatch() just exist for testing purpose.
That is a smell. It tells us that the design is not quite right or that we
should be looking at other side effects in order to test the desired behaviour.

Wall: Probably unnecessary if the repository could return a list posts, in the
reverse chronological order for a given user (containing the list of followed
users).

dal package: Did you mean “dao” (Data Access Object)? You should not mix DAO
and Repositories. Although similar things, they represent different concepts.
DAO is a Core J2EE Pattern and Repository is a DDD building block, which treat
entities/aggregates as a collection. Subtle but different. In a DAO you would
have “create”, “read”, “delete”, etc. In a Repository you would have “add”,
“find”, “remove”.



**Consideration**

It’s clear that James has a good experience with Cucumber and Acceptance Tests
but I think that if he had more unit tests, the overall design would have been
improved. Looking at the code, I can clearly see that James is a very confident
developer. Design-wise, I think that there is room for improvement. Also, I
believe that the bug in the wall feature was a consequence of lack of tests and
how the data was “stored”—too many pieces in there. I could find some Ruby
influence in his code, which is not a bad thing. However, in this case, it led
him to use type casting and “instanceof” instead of a better use of OO. Probably
because in Ruby, as it is a dynamic language, he wouldn’t need to do any of that.
He would just invoke the method and that would work. My recommendation to James
is to try to get a deeper knowledge of design patterns, DDD, and OCP (SOLID),
and also to use more unit tests as well.